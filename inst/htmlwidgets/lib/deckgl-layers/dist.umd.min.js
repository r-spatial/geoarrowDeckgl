/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/@geoarrow/deck.gl-layers@0.3.0/dist/dist.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@deck.gl/core"),require("@deck.gl/layers"),require("@geoarrow/geoarrow-js"),require("apache-arrow"),require("@deck.gl/geo-layers"),require("@deck.gl/aggregation-layers"),require("threads")):"function"==typeof define&&define.amd?define(["exports","@deck.gl/core","@deck.gl/layers","@geoarrow/geoarrow-js","apache-arrow","@deck.gl/geo-layers","@deck.gl/aggregation-layers","threads"],e):e(((t="undefined"!=typeof globalThis?globalThis:t||self)["@geoarrow/deck"]=t["@geoarrow/deck"]||{},t["@geoarrow/deck"]["gl-layers"]={}),t.deck,t.deck,t.geoarrow,t.Arrow,t.deck,t.deck,t.threads)}(this,(function(t,e,r,o,s,i,n,a){"use strict";function l(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var o=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,o.get?o:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var c=l(o),d=l(s);function p(t){if(d.DataType.isList(t.type))return p(t.children[0]);if(d.DataType.isStruct(t.type))return!0;if(d.DataType.isFixedSizeList(t.type))return!1;throw new Error(`Unsupported geometry data type: ${t.type}`)}function h(t){if(e=t,d.DataType.isFixedSizeList(e.type))return t;if(function(t){return d.DataType.isStruct(t.type)}(t)){const e=t.children.length,r=new Float64Array(t.length*e);for(let o=0;o<t.length;o++)for(let s=0;s<e;s++)r[o*e+s]=t.children[s].values[o];const o=new d.Float64,s=new d.FixedSizeList(e,new d.Field("coords",o)),i=d.makeData({type:o,length:r.length,data:r});return d.makeData({type:s,length:t.length,nullCount:t.nullCount,nullBitmap:t.nullBitmap,child:i})}var e;throw new Error(`Unsupported coordinate data type: ${t.type}`)}function g(t){const e=h(c.child.getLineStringChild(t));return d.makeData({type:new d.List(new d.Field("element",e.type)),length:t.length,nullCount:t.nullCount,nullBitmap:t.nullBitmap,valueOffsets:t.valueOffsets,offset:t.offset,child:e})}function u(t){const e=g(c.child.getPolygonChild(t));return d.makeData({type:new d.List(new d.Field("element",e.type)),length:t.length,nullCount:t.nullCount,nullBitmap:t.nullBitmap,valueOffsets:t.valueOffsets,offset:t.offset,child:e})}function f(t){const{props:r,propName:o,propInput:s,chunkIdx:i,geomCoordOffsets:n}=t;if(void 0!==s)if(s instanceof d.Vector){const t=s.data[i];if(d.DataType.isFixedSizeList(t)){e.assert(1===t.children.length);let s=t.children[0].values;n&&(s=y(s,t.type.listSize,n)),r.data.attributes[o]={value:s,size:t.type.listSize,normalized:!0}}else if(d.DataType.isFloat(t)){let e=t.values;n&&(e=y(e,1,n)),r.data.attributes[o]={value:e,size:1}}}else r[o]="function"==typeof s?(t,e)=>"getPolygonOffset"===o?s(t,e):function(t,e){const{index:r,data:o}=t;let s=r;return void 0!==o.invertedGeomOffsets&&(s=o.invertedGeomOffsets[r]),e({index:s,data:{data:o.data,length:o.length,attributes:o.attributes},target:t.target})}(e,s):s}function y(t,e,r){const o=r[r.length-1],s=new t.constructor(o*e);for(let o=0;o<r.length-1;o++){const i=r[o],n=r[o+1];for(let r=i;r<n;r++)for(let i=0;i<e;i++)s[r*e+i]=t[o*e+i]}return s}function P(t,e){const r=function(t,e,r){const o=t.fields.findIndex((t=>t.name===r||t.metadata.get("ARROW:extension:name")===e));return-1!==o?o:null}(t.schema,e);return null===r?null:t.getChildAt(r)}function L(t){const e=t.valueOffsets,r=c.child.getMultiLineStringChild(t).valueOffsets,o=new Int32Array(e.length);for(let t=0;t<o.length;++t)o[t]=r[e[t]];return o}function w(t){const e=t.valueOffsets,r=c.child.getPolygonChild(t).valueOffsets,o=new Int32Array(e.length);for(let t=0;t<o.length;++t)o[t]=r[e[t]];return o}function v(t){const e=c.child.getMultiPolygonChild(t),r=c.child.getPolygonChild(e),o=t.valueOffsets,s=e.valueOffsets,i=r.valueOffsets,n=new Int32Array(o.length);for(let t=0;t<n.length;++t)n[t]=i[s[o[t]]];return n}function m(t){const e=t[t.length-1],r=new(t.length<Math.pow(2,8)?Uint8Array:t.length<Math.pow(2,16)?Uint16Array:Uint32Array)(e);for(let e=0;e<t.length-1;e++){const o=t[e],s=t[e+1];for(let t=o;t<s;t++)r[t]=e}return r}function b(t,e){const r={},o={};for(const[s,i]of Object.entries(t))e.includes(s)||(s.startsWith("get")?r[s]=i:o[s]=i);return[r,o]}function O({info:t,sourceLayer:e},r){let o=t.index;e.props.data.invertedGeomOffsets&&(o=e.props.data.invertedGeomOffsets[o]);const s=e.props.recordBatchIdx,i=e.props.tableOffsets,n=r.batches[s].get(o);if(null===n)return t;return o+=i[s],{...t,index:o,object:n}}function S(t){return t.reduce(((t,e,r)=>(t[r+1]=t[r]+e.length,t)),new Uint32Array(t.length+1))}function C(t,r){const o=[],s=[];for(const[e,r]of Object.entries(t))e.startsWith("get")&&r instanceof d.Vector&&(o.push(r),e.endsWith("Color")&&s.push(r));!function(t,r){for(const o of r)e.assert(t.batches.length===o.data.length);for(const o of r)for(let r=0;r<t.batches.length;r++)e.assert(t.batches[r].numRows===o.data[r].length)}(r,o);for(const t of s)_(t)}function _(t){e.assert(d.DataType.isFixedSizeList(t.type)),e.assert(3===t.type.listSize||4===t.type.listSize),e.assert(d.DataType.isInt(t.type.children[0])),e.assert(8===t.type.children[0].type.bitWidth)}const{data:I,getSourcePosition:x,getTargetPosition:T,...k}=r.ArcLayer.defaultProps,M={_validate:!0},A={...k,...M};class V extends e.CompositeLayer{static defaultProps=A;static layerName="GeoArrowArcLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){return this._renderLayersPoint()}_renderLayersPoint(){const{data:t,getSourcePosition:s,getTargetPosition:i}=this.props;this.props._validate&&(C(this.props,t),e.assert(c.vector.isPointVector(s)),e.assert(c.vector.isPointVector(i)));const[n,a]=b(this.props,["getSourcePosition","getTargetPosition"]),l=S(t.data),d=[];for(let e=0;e<t.batches.length;e++){let c=s.data[e];p(c)&&(c=h(c));const g=o.child.getPointChild(c).values;let u=i.data[e];p(u)&&(u=h(u));const y=o.child.getPointChild(u).values,P={...M,...a,recordBatchIdx:e,tableOffsets:l,id:`${this.props.id}-geoarrow-arc-${e}`,data:{data:t.batches[e],length:c.length,attributes:{getSourcePosition:{value:g,size:c.type.listSize},getTargetPosition:{value:y,size:u.type.listSize}}}};for(const[t,r]of Object.entries(n))f({props:P,propName:t,propInput:r,chunkIdx:e});const L=new r.ArcLayer(this.getSubLayerProps(P));d.push(L)}return d}}var z;!function(t){t.POINT="geoarrow.point",t.LINESTRING="geoarrow.linestring",t.POLYGON="geoarrow.polygon",t.MULTIPOINT="geoarrow.multipoint",t.MULTILINESTRING="geoarrow.multilinestring",t.MULTIPOLYGON="geoarrow.multipolygon"}(z||(z={}));const{data:N,getPosition:G,...E}=r.ColumnLayer.defaultProps,W={_validate:!0},j={...E,...W};class $ extends e.CompositeLayer{static defaultProps=j;static layerName="GeoArrowColumnLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{data:t}=this.props,e=P(t,z.POINT);if(null!==e)return this._renderLayersPoint(e);const r=this.props.getPosition;if(void 0!==r&&c.vector.isPointVector(r))return this._renderLayersPoint(r);throw new Error("getPosition not GeoArrow point")}_renderLayersPoint(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isPointVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPosition"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){let l=t.data[e];p(l)&&(l=h(l));const d=c.child.getPointChild(l).values,g={...W,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-column-${e}`,data:{data:o.batches[e],length:l.length,attributes:{getPosition:{value:d,size:l.type.listSize}}}};for(const[t,r]of Object.entries(s))f({props:g,propName:t,propInput:r,chunkIdx:e});const u=new r.ColumnLayer(this.getSubLayerProps(g));a.push(u)}return a}}const{data:B,getHexagon:D,...U}=i.H3HexagonLayer.defaultProps,F={_validate:!0},H={...U,...F};class R extends e.CompositeLayer{static defaultProps=H;static layerName="GeoArrowH3HexagonLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){return this._renderLayersPoint()}_renderLayersPoint(){const{data:t,getHexagon:e}=this.props;this.props._validate&&C(this.props,t);const[r,o]=b(this.props,["getHexagon"]),s=S(t.data),n=[];for(let a=0;a<t.batches.length;a++){const l=e.data[a],c=l.values,d={...F,...o,recordBatchIdx:a,tableOffsets:s,id:`${this.props.id}-geoarrow-arc-${a}`,data:{data:t.batches[a],length:l.length,attributes:{getHexagon:{value:c,size:15}}}};for(const[t,e]of Object.entries(r))f({props:d,propName:t,propInput:e,chunkIdx:a});const p=new i.H3HexagonLayer(this.getSubLayerProps(d));n.push(p)}return n}}const{data:q,getPosition:Y,...J}=n.HeatmapLayer.defaultProps,K={_validate:!0},Q={...J,...K};class X extends e.CompositeLayer{static defaultProps=Q;static layerName="GeoArrowHeatmapLayer";renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPosition){const t=this.props.getPosition;if(void 0!==t&&c.vector.isPointVector(t))return this._renderLayersPoint(t);throw new Error("getPosition should pass in an arrow Vector of Point type")}{const e=P(t,z.POINT);if(null!==e)return this._renderLayersPoint(e)}throw new Error("getPosition not GeoArrow point")}_renderLayersPoint(t){const{data:r}=this.props;this.props._validate&&(e.assert(c.vector.isPointVector(t)),C(this.props,r));const[o,s]=b(this.props,["getPosition"]),i=S(r.data),a=[];for(let e=0;e<r.batches.length;e++){let l=t.data[e];p(l)&&(l=h(l));const d=c.child.getPointChild(l).values,g={...K,...s,recordBatchIdx:e,tableOffsets:i,id:`${this.props.id}-geoarrow-heatmap-${e}`,data:{data:r.batches[e],length:l.length,attributes:{getPosition:{value:d,size:l.type.listSize}}}};for(const[t,r]of Object.entries(o))f({props:g,propName:t,propInput:r,chunkIdx:e});const u=new n.HeatmapLayer(this.getSubLayerProps(g));a.push(u)}return a}}const{data:Z,getPath:tt,...et}=r.PathLayer.defaultProps,rt={_pathType:"open",_validate:!0},ot={...et,...rt};class st extends e.CompositeLayer{static defaultProps=ot;static layerName="GeoArrowPathLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPath){const t=this.props.getPath;if(void 0!==t&&c.vector.isLineStringVector(t))return this._renderLayersLineString(t);if(void 0!==t&&c.vector.isMultiLineStringVector(t))return this._renderLayersMultiLineString(t);throw new Error("getPath should be an arrow Vector of LineString or MultiLineString type")}{const e=P(t,z.LINESTRING);if(null!==e)return this._renderLayersLineString(e);const r=P(t,z.MULTILINESTRING);if(null!==r)return this._renderLayersMultiLineString(r)}throw new Error("getPath not GeoArrow LineString or MultiLineString")}_renderLayersLineString(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isLineStringVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPath"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){let l=t.data[e];p(l)&&(l=g(l));const d=l.valueOffsets,h=c.child.getLineStringChild(l),u=h.type.listSize,y=c.child.getPointChild(h).values,P={...rt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-path-${e}`,data:{data:o.batches[e],length:l.length,startIndices:d,attributes:{getPath:{value:y,size:u}}}};for(const[t,r]of Object.entries(s))f({props:P,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:d});const L=new r.PathLayer(this.getSubLayerProps(P));a.push(L)}return a}_renderLayersMultiLineString(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isMultiLineStringVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPath"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){const l=t.data[e];let d=c.child.getMultiLineStringChild(l);p(d)&&(d=g(d));const h=c.child.getLineStringChild(d),u=c.child.getPointChild(h),y=l.valueOffsets,P=d.valueOffsets,w=h.type.listSize,v=u.values,b=L(l),O={...rt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-path-${e}`,data:{data:o.batches[e],invertedGeomOffsets:m(y),length:d.length,startIndices:P,attributes:{getPath:{value:v,size:w}}}};for(const[t,r]of Object.entries(s))f({props:O,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:b});const S=new r.PathLayer(this.getSubLayerProps(O));a.push(S)}return a}}const{data:it,getPosition:nt,...at}=r.PointCloudLayer.defaultProps,lt={_validate:!0},ct={...at,...lt};class dt extends e.CompositeLayer{static defaultProps=ct;static layerName="GeoArrowPointCloudLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPosition){const t=this.props.getPosition;if(void 0!==t&&c.vector.isPointVector(t))return this._renderLayersPoint(t);throw new Error("getPosition should pass in an arrow Vector of Point type")}{const e=P(t,z.POINT);if(null!==e)return this._renderLayersPoint(e)}throw new Error("getPosition not GeoArrow point")}_renderLayersPoint(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isPointVector(t),"The geometry column is not a valid PointVector."),e.assert(3===t.type.listSize,"Points of a PointCloudLayer in the geometry column must be three-dimensional."),C(this.props,o));const[s,i]=b(this.props,["getPosition"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){let l=t.data[e];p(l)&&(l=h(l));const d=c.child.getPointChild(l).values,g={...lt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-pointcloud-${e}`,data:{data:o.batches[e],length:l.length,attributes:{getPosition:{value:d,size:l.type.listSize}}}};for(const[t,r]of Object.entries(s))f({props:g,propName:t,propInput:r,chunkIdx:e});const u=new r.PointCloudLayer(this.getSubLayerProps(g));a.push(u)}return a}}const{data:pt,getPolygon:ht,...gt}=r.SolidPolygonLayer.defaultProps,ut={_normalize:!1,_windingOrder:"CCW",_validate:!0,earcutWorkerUrl:"https://cdn.jsdelivr.net/npm/@geoarrow/geoarrow-js@0.3.0/dist/earcut-worker.min.js",earcutWorkerPoolSize:8},ft={...gt,...ut};class yt extends e.CompositeLayer{static defaultProps=ft;static layerName="GeoArrowSolidPolygonLayer";initializeState(t){this.state={table:null,tableOffsets:null,triangles:null,earcutWorkerRequest:null===this.props.earcutWorkerUrl||void 0===this.props.earcutWorkerUrl?null:fetch(this.props.earcutWorkerUrl).then((t=>t.text())),earcutWorkerPool:null}}async initEarcutPool(){if(this.state.earcutWorkerPool)return this.state.earcutWorkerPool;const t=await this.state.earcutWorkerRequest;if(!t)return null;if(window?.location?.href.startsWith("file://"))return null;try{const e=a.Pool((()=>a.spawn(a.BlobWorker.fromText(t))),8);return this.state.earcutWorkerPool=e,this.state.earcutWorkerPool}catch(t){return null}}async finalizeState(t){await(this.state?.earcutWorkerPool?.terminate()),console.log("terminated")}async updateData(){const{data:t}=this.props,e=await this._updateEarcut(t),r=S(t.data);this.setState({table:this.props.data,triangles:e,tableOffsets:r})}async _updateEarcut(t){const e=P(t,z.POLYGON);if(null!==e)return this._earcutPolygonVector(e);const r=P(t,z.MULTIPOLYGON);if(null!==r)return this._earcutMultiPolygonVector(r);const o=this.props.getPolygon;if(void 0!==o&&c.vector.isPolygonVector(o))return this._earcutPolygonVector(o);if(void 0!==o&&c.vector.isMultiPolygonVector(o))return this._earcutMultiPolygonVector(o);throw new Error("geometryColumn not Polygon or MultiPolygon")}async _earcutPolygonVector(t){const e=await this.initEarcutPool();if(!e)return this._earcutPolygonVectorMainThread(t);const r=new Array(t.data.length);console.time("earcut");for(let o=0;o<t.data.length;o++){let s=t.data[o];p(s)&&(s=u(s));const[i,n]=c.worker.preparePostMessage(s,!0);e.queue((async t=>{const e=await t(a.Transfer(i,n));r[o]=e}))}return await e.completed(),console.timeEnd("earcut"),r}_earcutPolygonVectorMainThread(t){const e=new Array(t.data.length);for(let r=0;r<t.data.length;r++){let o=t.data[r];p(o)&&(o=u(o)),e[r]=c.algorithm.earcut(o)}return e}async _earcutMultiPolygonVector(t){const e=await this.initEarcutPool();if(!e)return this._earcutMultiPolygonVectorMainThread(t);const r=new Array(t.data.length);console.time("earcut");for(let o=0;o<t.data.length;o++){const s=t.data[o];let i=c.child.getMultiPolygonChild(s);p(i)&&(i=u(i));const[n,l]=c.worker.preparePostMessage(i,!0);e.queue((async t=>{const e=await t(a.Transfer(n,l));r[o]=e}))}return await e.completed(),console.timeEnd("earcut"),r}_earcutMultiPolygonVectorMainThread(t){const e=new Array(t.data.length);for(let r=0;r<t.data.length;r++){const o=t.data[r];let s=c.child.getMultiPolygonChild(o);p(s)&&(s=u(s)),e[r]=c.algorithm.earcut(s)}return e}updateState({props:t,changeFlags:e}){e.dataChanged&&this.updateData()}getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{table:t}=this.state;if(!t)return null;if(void 0!==this.props.getPolygon){const t=this.props.getPolygon;if(void 0!==t&&c.vector.isPolygonVector(t))return this._renderLayersPolygon(t);if(void 0!==t&&c.vector.isMultiPolygonVector(t))return this._renderLayersMultiPolygon(t);throw new Error("getPolygon should be an arrow Vector of Polygon or MultiPolygon type")}{const e=P(t,z.POLYGON);if(null!==e)return this._renderLayersPolygon(e);const r=P(t,z.MULTIPOLYGON);if(null!==r)return this._renderLayersMultiPolygon(r)}throw new Error("getPolygon not GeoArrow Polygon or MultiPolygon")}_renderLayersPolygon(t){const{table:o}=this.state;if(!o)return null;this.props._validate&&(e.assert(c.vector.isPolygonVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPolygon"]),n=[];for(let e=0;e<o.batches.length;e++){let a=t.data[e];p(a)&&(a=u(a));const l=c.child.getPolygonChild(a),d=c.child.getLineStringChild(l),h=c.child.getPointChild(d),g=d.type.listSize,y=h.values,P=w(a);if(!this.state.triangles)return null;const L=this.state.triangles[e],v={...ut,...i,recordBatchIdx:e,tableOffsets:this.state.tableOffsets,id:`${this.props.id}-geoarrow-point-${e}`,data:{data:o.batches[e],length:a.length,startIndices:P,attributes:{getPolygon:{value:y,size:g},indices:{value:L,size:1}}}};for(const[t,r]of Object.entries(s))f({props:v,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:P});const m=new r.SolidPolygonLayer(this.getSubLayerProps(v));n.push(m)}return n}_renderLayersMultiPolygon(t){const{table:o}=this.state;if(!o)return null;this.props._validate&&(e.assert(c.vector.isMultiPolygonVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPolygon"]),n=[];for(let e=0;e<o.batches.length;e++){const a=t.data[e];let l=c.child.getMultiPolygonChild(a);p(l)&&(l=u(l));const d=c.child.getPolygonChild(l),h=c.child.getLineStringChild(d),g=c.child.getPointChild(h),y=h.type.listSize,P=a.valueOffsets,L=g.values;if(!this.state.triangles)return null;const b=this.state.triangles[e],O=w(l),S=v(a),C={...ut,...i,recordBatchIdx:e,tableOffsets:this.state.tableOffsets,id:`${this.props.id}-geoarrow-solid-polygon-multi-${e}`,data:{data:o.batches[e],invertedGeomOffsets:m(P),length:l.length,startIndices:O,attributes:{getPolygon:{value:L,size:y},indices:{value:b,size:1}}}};for(const[t,r]of Object.entries(s))f({props:C,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:S});const _=this.getSubLayerProps(C),I=new r.SolidPolygonLayer(_);n.push(I)}return n}}function Pt(t){return"data"in t?new d.Vector(t.data.map((t=>Pt(t)))):t}function Lt(t){if("data"in t)return new d.Vector(t.data.map((t=>Lt(t))));const e=t.valueOffsets,r=c.child.getMultiPolygonChild(t),o=r.valueOffsets,s=c.child.getPolygonChild(r),i=new Int32Array(e.length);for(let t=0;t<i.length;++t)i[t]=o[e[t]];return d.makeData({type:new d.List(r.type.children[0]),length:t.length,nullCount:t.nullCount,nullBitmap:t.nullBitmap,child:s,valueOffsets:i})}const{data:wt,getPolygon:vt,...mt}=r.PolygonLayer.defaultProps,bt={...mt,_normalize:!1,_windingOrder:"CCW",_validate:!0},Ot=[0,0,0,255];class St extends e.CompositeLayer{static defaultProps=bt;static layerName="GeoArrowPolygonLayer";getPickingInfo(t){return t.info}renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPolygon){const t=this.props.getPolygon;if(c.vector.isPolygonVector(t))return this._renderLayers(t);if(c.vector.isMultiPolygonVector(t))return this._renderLayers(t);throw new Error("getPolygon should be an arrow Vector of Polygon or MultiPolygon type")}{const e=P(t,z.POLYGON);if(null!==e)return this._renderLayers(e);const r=P(t,z.MULTIPOLYGON);if(null!==r)return this._renderLayers(r)}throw new Error("geometryColumn not Polygon or MultiPolygon")}_renderLayers(t){const{data:r}=this.props;let o;c.vector.isPolygonVector(t)?o=Pt(t):c.vector.isMultiPolygonVector(t)?o=Lt(t):e.assert(!1);const{data:s,_dataDiff:i,stroked:n,filled:a,extruded:l,wireframe:d,_normalize:p,_windingOrder:h,elevationScale:g,transitions:u,positionFormat:f}=this.props,{lineWidthUnits:y,lineWidthScale:P,lineWidthMinPixels:L,lineWidthMaxPixels:w,lineJointRounded:v,lineMiterLimit:m,lineDashJustified:b}=this.props,{getFillColor:O,getLineColor:S,getLineWidth:C,getElevation:_,getPolygon:I,updateTriggers:x,material:T}=this.props,k=this.getSubLayerClass("fill",yt),M=this.getSubLayerClass("stroke",st),A=new k({extruded:l,elevationScale:g,filled:a,wireframe:d,_normalize:p,_windingOrder:h,getElevation:_,getFillColor:O,getLineColor:l&&d?S:Ot,material:T,transitions:u},this.getSubLayerProps({id:"fill",updateTriggers:x&&{getPolygon:x.getPolygon,getElevation:x.getElevation,getFillColor:x.getFillColor,getLineColor:x.getLineColor}}),{data:s,positionFormat:f,getPolygon:I});return[!l&&A,!l&&n&&new M({widthUnits:y,widthScale:P,widthMinPixels:L,widthMaxPixels:w,jointRounded:v,miterLimit:m,dashJustified:b,_pathType:"loop",transitions:u&&{getWidth:u.getLineWidth,getColor:u.getLineColor,getPath:u.getPolygon},getColor:this.getSubLayerAccessor(S),getWidth:this.getSubLayerAccessor(C)},this.getSubLayerProps({id:"stroke",updateTriggers:x&&{getWidth:x.getLineWidth,getColor:x.getLineColor,getDashArray:x.getLineDashArray}}),{data:r,positionFormat:f,getPath:o,pickable:!1}),l&&A]}}const{data:Ct,getPosition:_t,...It}=r.ScatterplotLayer.defaultProps,xt={_validate:!0},Tt={...It,...xt};class kt extends e.CompositeLayer{static defaultProps=Tt;static layerName="GeoArrowScatterplotLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPosition){const t=this.props.getPosition;if(void 0!==t&&c.vector.isPointVector(t))return this._renderLayersPoint(t);if(void 0!==t&&c.vector.isMultiPointVector(t))return this._renderLayersMultiPoint(t);throw new Error("getPosition should pass in an arrow Vector of Point or MultiPoint type")}{const e=P(t,z.POINT);if(null!==e)return this._renderLayersPoint(e);const r=P(t,z.MULTIPOINT);if(null!==r)return this._renderLayersMultiPoint(r)}throw new Error("getPosition not GeoArrow point or multipoint")}_renderLayersPoint(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isPointVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPosition"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){let l=t.data[e];p(l)&&(l=h(l));const d=c.child.getPointChild(l).values,g={...xt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-scatterplot-${e}`,data:{data:o.batches[e],length:l.length,attributes:{getPosition:{value:d,size:l.type.listSize}}}};for(const[t,r]of Object.entries(s))f({props:g,propName:t,propInput:r,chunkIdx:e});const u=new r.ScatterplotLayer(this.getSubLayerProps(g));a.push(u)}return a}_renderLayersMultiPoint(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isMultiPointVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPosition"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){const l=t.data[e];let d=c.child.getMultiPointChild(l);p(d)&&(d=h(d));const g=l.valueOffsets,u=c.child.getPointChild(d).values,y={...xt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-scatterplot-${e}`,data:{data:o.batches[e],invertedGeomOffsets:m(g),length:d.length,attributes:{getPosition:{value:u,size:d.type.listSize}}}};for(const[t,r]of Object.entries(s))f({props:y,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:g});const P=new r.ScatterplotLayer(this.getSubLayerProps(y));a.push(P)}return a}}const{data:Mt,getPosition:At,getText:Vt,getTextAnchor:zt,getAlignmentBaseline:Nt,getPixelOffset:Gt,...Et}=r.TextLayer.defaultProps,Wt={getTextAnchor:"middle",getAlignmentBaseline:"center",getPixelOffset:[0,0],_validate:!0},jt={...Et,...Wt};class $t extends e.CompositeLayer{static defaultProps=jt;static layerName="GeoArrowTextLayer";getPickingInfo(t){return O(t,this.props.data)}renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPosition){const t=this.props.getPosition;if(void 0!==t&&c.vector.isPointVector(t))return this._renderLayersPoint(t);throw new Error("getPosition should pass in an arrow Vector of Point type")}{const e=P(t,z.POINT);if(null!==e)return this._renderLayersPoint(e)}throw new Error("getPosition not GeoArrow point")}_renderLayersPoint(t){const{data:o}=this.props;this.props._validate&&(e.assert(c.vector.isPointVector(t)),C(this.props,o));const[s,i]=b(this.props,["getPosition","getText"]),n=S(o.data),a=[];for(let e=0;e<o.batches.length;e++){let l=t.data[e];p(l)&&(l=h(l));const d=c.child.getPointChild(l).values,g=this.props.getText.data[e],u=g.values,P=g.valueOffsets,L={...Wt,...i,recordBatchIdx:e,tableOffsets:n,id:`${this.props.id}-geoarrow-heatmap-${e}`,data:{data:o.batches[e],length:l.length,startIndices:P,attributes:{getPosition:{value:y(d,l.type.listSize,P),size:l.type.listSize},getText:{value:u}}}};for(const[t,r]of Object.entries(s))f({props:L,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:P});const w=new r.TextLayer(this.getSubLayerProps(L));a.push(w)}return a}}const{data:Bt,getPath:Dt,...Ut}=ot,Ft={_pathType:"open",_validate:!0},Ht={...Ut,...Ft};class Rt extends e.CompositeLayer{static defaultProps=Ht;static layerName="GeoArrowTripsLayer";renderLayers(){const{data:t}=this.props;if(void 0!==this.props.getPath){const t=this.props.getPath;if(void 0!==t&&c.vector.isLineStringVector(t))return this._renderLayersLineString(t);throw new Error("getPath should be an arrow Vector of LineString type")}{const e=P(t,z.LINESTRING);if(null!==e)return this._renderLayersLineString(e)}throw new Error("getPath not GeoArrow LineString")}_renderLayersLineString(t){const{data:r}=this.props,o=this.props.getTimestamps;this.props._validate&&(e.assert(c.vector.isLineStringVector(t)),C(this.props,r));const[s,n]=b(this.props,["getPath","getTimestamps"]),a=S(r.data),l=[];for(let e=0;e<r.batches.length;e++){let d=t.data[e];p(d)&&(d=g(d));const h=d.valueOffsets,u=c.child.getLineStringChild(d),y=u.type.listSize,P=c.child.getPointChild(u).values,L=o.data[e].children[0].values,w={...Ft,...n,recordBatchIdx:e,tableOffsets:a,id:`${this.props.id}-geoarrow-trip-${e}`,data:{data:r.batches[e],length:d.length,startIndices:h,attributes:{getPath:{value:P,size:y},getTimestamps:{value:L,size:1}}}};for(const[t,r]of Object.entries(s))f({props:w,propName:t,propInput:r,chunkIdx:e,geomCoordOffsets:h});const v=new i.TripsLayer(w);l.push(v)}return l}}t.GeoArrowArcLayer=V,t.GeoArrowColumnLayer=$,t.GeoArrowHeatmapLayer=X,t.GeoArrowPathLayer=st,t.GeoArrowPointCloudLayer=dt,t.GeoArrowPolygonLayer=St,t.GeoArrowScatterplotLayer=kt,t.GeoArrowSolidPolygonLayer=yt,t.GeoArrowTripsLayer=Rt,t._GeoArrowH3HexagonLayer=R,t._GeoArrowTextLayer=$t}));
//# sourceMappingURL=dist.umd.js.map
